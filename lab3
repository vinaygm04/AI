import copy

goal_state = [[1, 2, 3],
              [8, 0, 4],
              [7, 6, 5]]

def heuristic(state):
    distance = 0
    for i in range(3):
        for j in range(3):
            value = state[i][j]
            if value != 0:
                for x in range(3):
                    for y in range(3):
                        if goal_state[x][y] == value:
                            distance += abs(i - x) + abs(j - y)
    return distance

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_blank(state)
    moves = {
        "Down": (1, 0),
        "Up": (-1, 0),
        "Right": (0, 1),
        "Left": (0, -1)
    }
    for move, (dx, dy) in moves.items():
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = copy.deepcopy(state)
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append((move, new_state))
    return neighbors

def hill_climbing(initial_state):
    current = initial_state
    current_h = heuristic(current)
    steps = 0
    path_moves = ["Start"]

    print("\nInitial State (h={}):".format(current_h))
    for row in current:
        print(row)

    while True:
        neighbors = get_neighbors(current)

        if not neighbors:
            print("\nNo more neighbors. Stopping.")
            return current, steps, current_h, path_moves

        print("\nStep {}: Generating neighbor states...".format(steps+1))
        for move, child in neighbors:
            print(f"\nMove: {move} (h={heuristic(child)})")
            for row in child:
                print(row)

        neighbor_move, neighbor = min(neighbors, key=lambda x: heuristic(x[1]))
        neighbor_h = heuristic(neighbor)

        print("\nChosen move: {} → h={}".format(neighbor_move, neighbor_h))
        for row in neighbor:
            print(row)

        if neighbor_h >= current_h:
            print("\nNo better neighbor found. Stopping.")
            return current, steps, current_h, path_moves

        current, current_h = neighbor, neighbor_h
        steps += 1
        path_moves.append(neighbor_move)

        if current_h == 0:
            print("\nGoal Reached!")
            return current, steps, current_h, path_moves

if __name__ == "__main__":
    initial_state = [[2, 8, 3],
                     [1, 0, 4],
                     [7, 6, 5]]

    solution, steps, h_val, path_moves = hill_climbing(initial_state)

    print("\nFinal State:")
    for row in solution:
        print(row)
    print(f"Steps taken: {steps}")
    print(f"Final Heuristic value: {h_val}")

    print("\nFinal Path of Moves:")
    print(" → ".join(path_moves))
     
Initial State (h=4):
[2, 8, 3]
[1, 0, 4]
[7, 6, 5]

Step 1: Generating neighbor states...

Move: Down (h=5)
[2, 8, 3]
[1, 6, 4]
[7, 0, 5]

Move: Up (h=3)
[2, 0, 3]
[1, 8, 4]
[7, 6, 5]

Move: Right (h=5)
[2, 8, 3]
[1, 4, 0]
[7, 6, 5]

Move: Left (h=5)
[2, 8, 3]
[0, 1, 4]
[7, 6, 5]

Chosen move: Up → h=3
[2, 0, 3]
[1, 8, 4]
[7, 6, 5]

Step 2: Generating neighbor states...

Move: Down (h=4)
[2, 8, 3]
[1, 0, 4]
[7, 6, 5]

Move: Right (h=4)
[2, 3, 0]
[1, 8, 4]
[7, 6, 5]

Move: Left (h=2)
[0, 2, 3]
[1, 8, 4]
[7, 6, 5]

Chosen move: Left → h=2
[0, 2, 3]
[1, 8, 4]
[7, 6, 5]

Step 3: Generating neighbor states...

Move: Down (h=1)
[1, 2, 3]
[0, 8, 4]
[7, 6, 5]

Move: Right (h=3)
[2, 0, 3]
[1, 8, 4]
[7, 6, 5]

Chosen move: Down → h=1
[1, 2, 3]
[0, 8, 4]
[7, 6, 5]

Step 4: Generating neighbor states...

Move: Down (h=2)
[1, 2, 3]
[7, 8, 4]
[0, 6, 5]

Move: Up (h=2)
[0, 2, 3]
[1, 8, 4]
[7, 6, 5]

Move: Right (h=0)
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]

Chosen move: Right → h=0
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]

Goal Reached!

Final State:
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]
Steps taken: 4
Final Heuristic value: 0

Final Path of Moves:
Start → Up → Left → Down → Right
No. of Misplaced Tiles


import copy

goal_state = [[1, 2, 3],
              [4, 5, 6],
              [7, 8, 0]]

def heuristic(state):
    misplaced = 0
    for i in range(3):
        for j in range(3):
            if state[i][j] != 0 and state[i][j] != goal_state[i][j]:
                misplaced += 1
    return misplaced

def find_blank(state):
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j

def get_neighbors(state):
    neighbors = []
    x, y = find_blank(state)
    moves = {
        "Down": (1, 0),
        "Up": (-1, 0),
        "Right": (0, 1),
        "Left": (0, -1)
    }
    for move, (dx, dy) in moves.items():
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = copy.deepcopy(state)
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            neighbors.append((move, new_state))
    return neighbors

def hill_climbing(initial_state):
    current = initial_state
    current_h = heuristic(current)
    steps = 0
    path_moves = ["Start"]

    print("\nInitial State (h={}):".format(current_h))
    for row in current:
        print(row)

    while True:
        neighbors = get_neighbors(current)

        if not neighbors:
            print("\nNo more neighbors. Stopping.")
            return current, steps, current_h, path_moves

        print("\nStep {}: Generating neighbor states...".format(steps+1))
        for move, child in neighbors:
            print(f"\nMove: {move} (h={heuristic(child)})")
            for row in child:
                print(row)

        neighbor_move, neighbor = min(neighbors, key=lambda x: heuristic(x[1]))
        neighbor_h = heuristic(neighbor)

        print("\nChosen move: {} → h={}".format(neighbor_move, neighbor_h))
        for row in neighbor:
            print(row)

        if neighbor_h >= current_h:
            print("\nNo better neighbor found. Stopping.")
            return current, steps, current_h, path_moves

        current, current_h = neighbor, neighbor_h
        steps += 1
        path_moves.append(neighbor_move)

        if current_h == 0:
            print("\nGoal Reached!")
            return current, steps, current_h, path_moves

if __name__ == "__main__":
    initial_state = [[1, 2, 3],
                     [0, 4, 6],
                     [7, 5, 8]]

    solution, steps, h_val, path_moves = hill_climbing(initial_state)

    print("\nFinal State:")
    for row in solution:
        print(row)
    print(f"Steps taken: {steps}")
    print(f"Final Heuristic value: {h_val}")

    print("\nFinal Path of Moves:")
    print(" → ".join(path_moves))
     
Initial State (h=3):
[1, 2, 3]
[0, 4, 6]
[7, 5, 8]

Step 1: Generating neighbor states...

Move: Down (h=4)
[1, 2, 3]
[7, 4, 6]
[0, 5, 8]

Move: Up (h=4)
[0, 2, 3]
[1, 4, 6]
[7, 5, 8]

Move: Right (h=2)
[1, 2, 3]
[4, 0, 6]
[7, 5, 8]

Chosen move: Right → h=2
[1, 2, 3]
[4, 0, 6]
[7, 5, 8]

Step 2: Generating neighbor states...

Move: Down (h=1)
[1, 2, 3]
[4, 5, 6]
[7, 0, 8]

Move: Up (h=3)
[1, 0, 3]
[4, 2, 6]
[7, 5, 8]

Move: Right (h=3)
[1, 2, 3]
[4, 6, 0]
[7, 5, 8]

Move: Left (h=3)
[1, 2, 3]
[0, 4, 6]
[7, 5, 8]

Chosen move: Down → h=1
[1, 2, 3]
[4, 5, 6]
[7, 0, 8]

Step 3: Generating neighbor states...

Move: Up (h=2)
[1, 2, 3]
[4, 0, 6]
[7, 5, 8]

Move: Right (h=0)
[1, 2, 3]
[4, 5, 6]
[7, 8, 0]

Move: Left (h=2)
[1, 2, 3]
[4, 5, 6]
[0, 7, 8]

Chosen move: Right → h=0
[1, 2, 3]
[4, 5, 6]
[7, 8, 0]

Goal Reached!

Final State:
[1, 2, 3]
[4, 5, 6]
[7, 8, 0]
Steps taken: 3
Final Heuristic value: 0

Final Path of Moves:
Start → Right → Down → Right
